<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Thea Flowers">
  <link rel="shortcut icon" href="https://blog.thea.codes/favicon.ico">

  <title>Using Python to vectorize artwork for PCBs - Stargirl (Thea) Flowers</title>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" href="https://blog.thea.codes/feed.xml" />

  <!-- Bootstrap core CSS -->
  <link href="/static/bootstrap.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="/static/style.css" rel="stylesheet">

  <!-- Syntax highlighting css -->
  <link href="/static/pygments.css" rel="stylesheet">

  
<meta property="og:title" content="Using Python to vectorize artwork for PCBs - Thea Flowers">
<meta property="twitter:title" content="Using Python to vectorize artwork for PCBs - Thea Flowers">


<meta property="og:description" content="Gluing together clever libraries to make beautiful printed circuit boards">
<meta property="twitter:description" content="Gluing together clever libraries to make beautiful printed circuit boards">






<meta property="og:url" content="https://blog.thea.codes/raster-vectorization-with-python">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@theavalkyrie">

</head>
<body>
  <div class="container">

    
<article>
  <aside class="timestamp">
    <time>Posted by Stargirl Flowers on August 23, 2022</time>
    Â· <a href="/">view all posts</a>
  </aside>
  <h1>Using Python to vectorize artwork for PCBs</h1>
  <content>
    <p>The maker community has long been creating <em>amazing</em> art with printed circuit boards (PCB). From the incredible variety of <a href="https://twitter.com/search?q=%23badgelife&amp;src=typed_query">#badgelife</a> from folks like <a href="https://www.tindie.com/stores/twinkletwinkie/">TwinkleTwinkie</a> to the <a href="https://www.alpenglowindustries.com/store.html#/">adorable and accessible kits</a> from folks like <a href="https://www.alpenglowindustries.com/#/">Alpenglow</a>, we've been misusing the circuit board fabrication process to great effect. I also (mis)use PCBs to create front panels for <a href="https://winterbloom.com">Winterbloom</a>'s modules:</p>
<p><img alt="PCB art photo" src="/static/2022-8-25/pcb-art.jpg" /></p>
<p>Unfortunately, the process of creating these works of art with industrial processes is not easy. Getting art into a manufacturable format<sup id="fnref:gerbers"><a class="footnote-ref" href="#fn:gerbers">1</a></sup> is filled with pitfalls and tedium. This has lead to some wonderful tools like <a href="https://github.com/badgeek/svg2shenzhen">svg2shenzhen</a>, <a href="https://github.com/jaseg/gerbolyze">Gerbolyze</a>, and <a href="https://pcbmode.com/">PCBmodE</a>- all of which are worth looking into if you want to do sort of thing.</p>
<p>Of course, this would be a disappointingly short and uninformative article if I just told you to go use those things. Which, by all means, if all you want to do is make art and get on with your life, then go for it! If you'd like to learn how all this works and fits together and learn how you might be able to automate parts of it, stick around!</p>
<p>In this article, I want to talk about just one approach for converting artwork for PCBs- <em><a href="https://en.wikipedia.org/wiki/Image_tracing">Image tracing</a></em>, sometimes called <em>raster-to-vector conversion</em>. This process takes a <em>raster</em> image (such a <code>png</code>) and converts it into a list of polygons. This article will show how I used Python to glue together a few clever libraries to build <a href="https://github.com/wntrblm/Gingerbread#using-trace">gingerbread.trace</a>, a tool for converting images into <a href="(https://www.kicad.org/)">KiCAD</a> footprints.</p>
<h2 id="the-challenge">The challenge</h2>
<p>Like many <a href="https://en.wikipedia.org/wiki/Electronic_design_automation">EDA</a>/<a href="https://en.wikipedia.org/wiki/Computer-aided_design">CAD</a> software packages, KiCAD works fundamentally differently from art design programs because it has a different purpose - KiCAD is for designing physical, manufacturable objects. The challenge presented here is to covert an image of some artwork into KiCAD's vector format.</p>
<p><img alt="Illustration of an artwork file named input.png and a KiCAD footprint named output.kicad_mod" src="/static/2022-8-25/in-out.png" /></p>
<p>The artwork can't necessary be perfectly translated so it will have to be <em>approximated</em>. Luckily, KiCAD includes a GUI program called <a href="https://docs.kicad.org/6.0/en/introduction/introduction.html#kicad-programs">bitmap2component</a> that can be used exactly for this purpose:</p>
<p><img alt="Picture of bitmap2component" src="/static/2022-8-25/bitmap2component.png" /></p>
<p>bitmap2component works but it has some drawbacks: it's a GUI program that's difficult to automate, it doesn't give you much control over the process, and it's frustrating to use with high-resolution images. Thankfully the KiCAD project is <a href="https://gitlab.com/kicad/code/kicad/-/tree/master/bitmap2component">open source</a> so it's possible learn how it works and build a similar tool that's works better for my use case.</p>
<h2 id="the-approach">The approach</h2>
<p>Alright, given an image this tool needs to generate a KiCAD footprint. Looking at bitmap2component, there's a few steps it goes through to accomplish this:</p>
<ol>
<li><em>Thresholding</em>: the image is reduced to a black &amp; white bitmap for the following steps to work correctly.</li>
<li><em>Tracing</em>: An image tracing algorithm analyzes the black &amp; white bitmap and generates a list of paths describing the filled areas in the image.</li>
<li><em>Polygon generation</em>: the paths are combined and transformed into polygons.</li>
<li><em>Footprint generation</em>: A KiCAD footprint is constructed from the polygons.</li>
</ol>
<p>Each of these steps have some unique challenges, so I'll go through them one at a time.</p>
<h2 id="thresholding">Thresholding</h2>
<p>The first step is to take the image and convert it to a black &amp; white bitmap.</p>
<p>While I could use the venerable <a href="https://pillow.readthedocs.io/en/stable/">Pillow</a> to perform the image processing needed, there's an excellent, high-performance image processing library called <a href="https://www.libvips.org/">vips</a> that can handle large images much more efficiently. Since I want to overcome bitmap2component's frustrating experience with high-resolution images, I decided to go with vips.</p>
<p>The thresholding is done in a few steps. The image is first converted into 8-bit grayscale and then each pixel is compared against a threshold and set to either <code>255</code> or <code>0</code>:</p>
<pre class="lang-python3"><span class="kn">import</span> <span class="nn">pyvips</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new_from_file</span><span class="p">(</span><span class="s2">&quot;input.png&quot;</span><span class="p">)</span>

<span class="c1"># Remove alpha</span>
<span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">hasalpha</span><span class="p">():</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">background</span><span class="o">=</span><span class="p">[</span><span class="mi">255</span><span class="p">])</span>

<span class="c1"># Convert to black and white.</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">colourspace</span><span class="p">(</span><span class="s2">&quot;b-w&quot;</span><span class="p">)</span>

<span class="c1"># Apply the threshold. Any pixels that are darker than 50% (less than 127) are</span>
<span class="c1"># considered filled areas, any pixels lighter than that are considered</span>
<span class="c1"># background. This threshold can be adjusted and inverted as needed.</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;</span> <span class="mi">127</span>
</pre>
<p>Here's the image at each step of the process:</p>
<p><img alt="Three pictures of the image going through the vips processing pipeline. The first shows the input image, the second shows the image in grayscale, the third shows the image in black and white." src="/static/2022-8-25/image-pipeline.png" /></p>
<h2 id="tracing">Tracing</h2>
<p>The next step is to analyze the bitmap and generate vectors. bitmap2component uses <a href="http://potrace.sourceforge.net/">Potrace</a>, a well established library used for image tracing.</p>
<p>While there are a couple of existing Python bindings to Potrace, they all fell short of exposing all the bits of Potrace I needed. I created my own bindings, <a href="https://github.com/wntrblm/potracecffi">potracecffi</a>, using <a href="https://cffi.readthedocs.io/en/latest/">cffi</a> - an excellent tool for creating bindings to C libraries.</p>
<p>Potrace's user interface is deceptively simple: it takes bitmap to analyze along with some optional parameters:</p>
<pre class="lang-python3"><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">turdsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">turnpolicy</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">TURNPOLICY_MINORITY</span><span class="p">,</span>
    <span class="n">alphamax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">opticurve</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">opttolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">):</span>
</pre>
<p>This is where I ran into the first real challenge with Potrace: getting the image data into the right format. While the thresholding process converted every pixel value into a binary black or white, each pixel still takes up one <strong>byte</strong> of space (or <em>8 bits per pixel</em>). Potrace expects the bitmap to be, well, a <a href="https://en.wikipedia.org/wiki/Bit_array">bitmap</a>! The image data needs to be tightly packed so that each <strong>bit</strong> represents a pixel (or <em>1 bit per pixel</em>).</p>
<p>It is possible to do this bitpacking in Python but it is dreadfully slow for larger images. Luckily, creating my own <code>cffi</code>-based bindings for Potrace meant that I could <a href="https://github.com/wntrblm/potracecffi/blob/main/potracecffi/potracecffi.c#L47">implement this bitpacking in C</a> as part of the <code>cffi</code> library. While I don't want to get into the weeds of how this works, it's important to note that sometimes when gluing together multiple libraries a little C can go a really long way in terms of improving importance and <code>cffi</code> is a good trick to have up your sleeve.</p>
<p>Now, <code>potracecffi</code> can take the 1 byte per pixel image data as a <a href="https://numpy.org/">Numpy</a> <code>array</code> (which vips will happily do) and it'll automatically handle the bitpacking it into a 1 bit per pixel array. Here's all the code needed to trace the image:</p>
<pre class="lang-python3"><span class="kn">import</span> <span class="nn">potracecffi</span>

<span class="n">bitmap</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

<span class="n">trace_result</span> <span class="o">=</span> <span class="n">potracecffi</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">bitmap</span><span class="p">)</span>
</pre>
<p>Potrace returns a list of <em>paths</em>. Each path has a list of segments (called <em>curves</em>, though I find that choice in terminology to be a bit confusing):</p>
<p><img alt="An illustration of a path that forms a polygon with another illustration showing the individual segments that make up the path" src="/static/2022-8-25/path-segments.png" /></p>
<h2 id="polygon-generation">Polygon generation</h2>
<p>Now that the image has been analyzed into a set of paths, the next step is to construct polygons from these paths. While it might seem as simple as iterating through the paths and creating a polygon from its segments, there are a few more hurdles to overcome.</p>
<p>The first is that Potrace path segments can be either lines or <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">cubic Bezier curves</a>:</p>
<p><img alt="An illustration of a line next to an illustration of a bezier curve" src="/static/2022-8-25/line-bezier.png" /></p>
<p>KiCAD's polygons must be a list of <em>points</em> forming line segments, so these Bezier curves need to be approximated by a series of lines. A very, very simple approach is to this is to use a constant number of line segments to approximate the curve<sup id="fnref:adaptive"><a class="footnote-ref" href="#fn:adaptive">3</a></sup>:</p>
<p><img alt="An illustration of a bezier curve approximated by line segments" src="/static/2022-8-25/bezier-approximation.png" /></p>
<p>This can be done by evaluating the Bezier formula once for each segment in the approximation:</p>
<pre class="lang-python3"><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># Type alias for a point</span>
<span class="n">point</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">bezier_to_points</span><span class="p">(</span><span class="n">p1</span><span class="p">:</span> <span class="n">point</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">point</span><span class="p">,</span> <span class="n">p3</span><span class="p">:</span> <span class="n">point</span><span class="p">,</span> <span class="n">p4</span><span class="p">:</span> <span class="n">point</span><span class="p">,</span> <span class="n">segments</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">segments</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>
            <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">p3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">p4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>
            <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">p3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">p4</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre>
<p>The next obstacle is that KiCAD needs <a href="https://en.wikipedia.org/wiki/Simple_polygon">simple polygons</a>- that is, polygons that do not contain any <strong>self-intersections</strong> or <strong>holes</strong>. Potrace's paths explicitly <strong>do not</strong> form simple polygons- they form <a href="https://en.wikipedia.org/wiki/Polygon_with_holes">polygons with holes</a>.</p>
<p><img alt="Illustration of a simple polygon next to a polygon with a hole" src="/static/2022-8-25/simple-and-hole.png" /></p>
<p>Potrace does offer some help here: each path has a <em>sign</em>. A positive sign indicates that the path is a polygon, while a negative sign indicates a hole. All holes for a given polygon are immediately after it in the list of paths. This can be visualized like this:</p>
<p><img alt="Picture of two polygons with holes in them and their paths numbered" src="/static/2022-8-25/numbered-paths.png" /></p>
<p>Path <code>1</code> is positive (shown in blue) so it is a polygon. The subsequent paths <code>2</code> and <code>3</code> are negative (shown in red), which indicates that they are holes in the polygon defined by path <code>1</code>. Path <code>4</code> is positive so it indicates a new polygon. Path <code>5</code> is negative so it indicates that it's a hole in the polygon defined by path <code>4</code>.</p>
<p>This information is used to create a list of polygons along with any holes in that polygon. From there, the polygons are be "simplified" by subtracting the holes using <a href="https://en.wikipedia.org/wiki/Boolean_operations_on_polygons">boolean operations</a>:</p>
<p><img alt="Illustration of two holes being subtracted from a polygon" src="/static/2022-8-25/boolean.png" /></p>
<p>Performing polygon operations like this is not for the faint of heart. bitmap2component uses the <a href="https://sourceforge.net/projects/polyclipping/">Clipper</a> library for polygon operations. There are Python bindings for Clipper, but unfortunately I didn't have any luck getting them to work. However, I came across the excellent <a href="https://github.com/heitzmann/gdstk">Gdstk</a> library which has many utilities for working with 2D polygons and uses Clipper behind the scenes. Gdstk also has the great benefit that resulting polygons are simple polygons and don't require any additional processing like <a href="https://en.wikipedia.org/wiki/Dissection_problem">dissection</a><sup id="fnref:fragmentation"><a class="footnote-ref" href="#fn:fragmentation">2</a></sup>, so they're ready for the journey into KiCAD.</p>
<p>Whew. With all that - a way to convert beziers to line segments, a way to organize the paths into polygons and holes, and a way to simplify the polygons, I can finally get a list of polygons from the Potrace result. This is surprisingly the most complicated code involved here!</p>
<p>First, here's the code for extracting the polygons and holes from the Potrace paths:</p>
<pre class="lang-python3"><span class="kn">import</span> <span class="nn">gdstk</span>

<span class="c1"># A list that contains lists where the first entry is a polygon and</span>
<span class="c1"># any subsequent entries in the list are holes in the polygon.</span>
<span class="n">polygons_and_holes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">gdstk</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Go through each path and pull out polygons and holes</span>
<span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">potracecffi</span><span class="o">.</span><span class="n">iter_paths</span><span class="p">(</span><span class="n">trace_result</span><span class="p">):</span>

    <span class="c1"># Go through each segment in the path and put together a list of points</span>
    <span class="c1"># that make up the polygon/hole.</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">potracecffi</span><span class="o">.</span><span class="n">curve_start_point</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">curve</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">potracecffi</span><span class="o">.</span><span class="n">iter_curve</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">curve</span><span class="p">):</span>

        <span class="c1"># Corner segments are simple lines from c1 to c2</span>
        <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">potracecffi</span><span class="o">.</span><span class="n">CORNER</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>

        <span class="c1"># Curveto segments are cubic bezier curves</span>
        <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">potracecffi</span><span class="o">.</span><span class="n">CURVETO</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span>
                    <span class="n">bezier_to_points</span><span class="p">(</span>
                        <span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">segment</span><span class="o">.</span><span class="n">c0</span><span class="p">,</span>
                        <span class="n">segment</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span>
                        <span class="n">segment</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="n">polygon</span> <span class="o">=</span> <span class="n">gdstk</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="c1"># Check the sign of the path, + means its a polygon and - means its a hole.</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">):</span>
        <span class="c1"># If it&#39;s a polygon, insert a new list with the polygon.</span>
        <span class="n">polygons_and_holes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">polygon</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If it&#39;s a hole, append it to the last polygon&#39;s list</span>
        <span class="n">polygons_and_holes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
</pre>
<p>Now that the polygons and holes are loaded into <code>gdstk.Polygon</code>s, they can be simplified:</p>
<pre class="lang-python3"><span class="c1"># Now take the list of polygons and holes and simplify them into a final list</span>
<span class="c1"># of simple polygons using boolean operations.</span>
<span class="n">polygons</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">gdstk</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">polygon</span><span class="p">,</span> <span class="o">*</span><span class="n">holes</span> <span class="ow">in</span> <span class="n">polygons_and_holes</span><span class="p">:</span>
    <span class="c1"># This polygon has no holes, so it&#39;s ready to go</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">holes</span><span class="p">:</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
        <span class="k">continue</span>

    <span class="c1"># Use boolean &quot;not&quot; to subtract all of the holes from the polygon.</span>
    <span class="n">results</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">gdstk</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdstk</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="s2">&quot;not&quot;</span><span class="p">)</span>

    <span class="c1"># Gdstk will return more than one polygon if the result can not be</span>
    <span class="c1"># represented with a simple polygon, so extend the list with the results.</span>
    <span class="n">polygons</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre>
<h2 id="footprint-generation">Footprint generation</h2>
<p>Alright, the hardest parts are done! The last step is to use those polygons to generate a KiCAD footprint. KiCAD uses a plain-text <a href="https://dev-docs.kicad.org/en/file-formats/sexpr-intro/index.html">S-expression</a> format for its files. The S-expression for <a href="https://dev-docs.kicad.org/en/file-formats/sexpr-intro/index.html#_footprint">footprints</a> is:</p>
<pre class="lang-lisp"><span class="p">(</span><span class="nv">footprint</span><span class="w"> </span><span class="s">&quot;Library:Name&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">layer</span><span class="w"> </span><span class="s">&quot;F.SilkS&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">at</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">attr</span><span class="w"> </span><span class="nv">board_only</span><span class="w"> </span><span class="nv">exclude_from_pos_files</span><span class="w"> </span><span class="nv">exclude_from_bom</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">tstamp</span><span class="w"> </span><span class="s">&quot;7a7d5548-24ac-11ed-8354-7a0c86e760e0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">tedit</span><span class="w"> </span><span class="s">&quot;7a7d5552-24ac-11ed-8354-7a0c86e760e0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">[GRAPHICS</span><span class="w"> </span><span class="nv">ITEMS]</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre>
<p>Other than the basic information<sup id="fnref:timestamps"><a class="footnote-ref" href="#fn:timestamps">4</a></sup>, the important bit is the <a href="https://dev-docs.kicad.org/en/file-formats/sexpr-intro/index.html#_footprint_graphics_items">graphics items</a>. This is where the polygon data will go. Each polygon is represented using an S-expression that contains list of points (<code>pts</code>) where each point is represented using the simple S-expression <code>(xy [X] [Y])</code>:</p>
<pre class="lang-lisp"><span class="p">(</span><span class="nv">fp_poly</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">pts</span><span class="w"></span>
<span class="w">    </span><span class="nv">[POINTS]</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">layer</span><span class="w"> </span><span class="s">&quot;F.SilkS&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">width</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">fill</span><span class="w"> </span><span class="nv">solid</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">tstamp</span><span class="w"> </span><span class="s">&quot;7a7d51f6-24ac-11ed-8354-7a0c86e760e0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre>
<p>Here's a simple footprint that puts all these parts together. The polygon inside is just a square, but you can copy and paste this into KiCAD if you want:</p>
<pre class="lang-lisp"><span class="p">(</span><span class="nv">footprint</span><span class="w"> </span><span class="s">&quot;Library:Name&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">layer</span><span class="w"> </span><span class="s">&quot;F.SilkS&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">at</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">attr</span><span class="w"> </span><span class="nv">board_only</span><span class="w"> </span><span class="nv">exclude_from_pos_files</span><span class="w"> </span><span class="nv">exclude_from_bom</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">tstamp</span><span class="w"> </span><span class="s">&quot;7a7d5548-24ac-11ed-8354-7a0c86e760e0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">tedit</span><span class="w"> </span><span class="s">&quot;7a7d5552-24ac-11ed-8354-7a0c86e760e0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">fp_poly</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nv">pts</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nv">xy</span><span class="w"> </span><span class="mi">-10</span><span class="w"> </span><span class="mi">-10</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nv">xy</span><span class="w"> </span><span class="mi">-10</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nv">xy</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nv">xy</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">-10</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nv">layer</span><span class="w"> </span><span class="s">&quot;F.SilkS&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nv">width</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nb">fill</span><span class="w"> </span><span class="nv">solid</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nv">tstamp</span><span class="w"> </span><span class="s">&quot;7a7d51f6-24ac-11ed-8354-7a0c86e760e0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre>
<p>The only trick here is that KiCAD expects the polygon's points to be in <em>millimeters</em> whereas the points in the polygons extracted from the image correspond to <em>pixels</em>. Up until this point, I haven't considered the physical size of the image. This is generally expressed in terms of <a href="https://en.wikipedia.org/wiki/Dots_per_inch">dots per inch</a> (DPI) (or pixels per inch)<sup id="fnref:dpi"><a class="footnote-ref" href="#fn:dpi">5</a></sup>, but it's easy enough to convert DPI from inches to millimeters:</p>
<pre class="lang-python3"><span class="n">dots_per_inch</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">dots_per_millimeter</span> <span class="o">=</span> <span class="mf">25.4</span> <span class="o">/</span> <span class="n">dots_per_inch</span>
</pre>
<p>That's the last piece of the puzzle needed to generate the footprint:</p>
<pre class="lang-python3"><span class="k">def</span> <span class="nf">fp_poly</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">point</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">points_mm</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">dots_per_millimeter</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">dots_per_millimeter</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
    <span class="p">)</span>
    <span class="n">points_sexpr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;(xy </span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">y</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points_mm</span><span class="p">))</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    (fp_poly</span>
<span class="s2">        (pts </span><span class="si">{</span><span class="n">points_sexpr</span><span class="si">}</span><span class="s2">)</span>
<span class="s2">        (layer &quot;F.SilkS&quot;)</span>
<span class="s2">        (width 0)</span>
<span class="s2">        (fill solid)</span>
<span class="s2">        (tstamp &quot;7a7d51f6-24ac-11ed-8354-7a0c86e760e0&quot;)</span>
<span class="s2">    )</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="n">poly_sexprs</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">fp_poly</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">)</span>

<span class="n">footprint</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">(footprint &quot;Library:Name&quot;</span>
<span class="s2">  (layer &quot;F.SilkS&quot;)</span>
<span class="s2">  (at 0 0)</span>
<span class="s2">  (attr board_only exclude_from_pos_files exclude_from_bom)</span>
<span class="s2">  (tstamp &quot;7a7d5548-24ac-11ed-8354-7a0c86e760e0&quot;)</span>
<span class="s2">  (tedit &quot;7a7d5552-24ac-11ed-8354-7a0c86e760e0&quot;)</span>
<span class="s2">  </span><span class="si">{</span><span class="n">poly_sexprs</span><span class="si">}</span><span class="s2"></span>
<span class="s2">)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pathlib</span>

<span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;footprint.kicad_mod&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write_text</span><span class="p">(</span><span class="n">footprint</span><span class="p">)</span>
</pre>
<p>The footprint can be copy/pasted or loaded into KiCAD's PCBNew:</p>
<p><img alt="Screenshot of the footprint in PCBNew" src="/static/2022-8-25/pcbnew.png" /></p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>You can reference and try out the <a href="https://gist.github.com/theacodes/2e13e4e05700279734ca4b34df370adb">full code</a> from this article if you'd like. Note that the code is meant to be educational, so it isn't going to look like production-ready code. You can take a look at <a href="https://github.com/wntrblm/Gingerbread#using-trace">gingerbread.trace</a> to see the concepts in this article adapted to a complete tool.</p>
<p>Hopefully this article has given some insight into raster-to-vector conversion and how Python can be used to glue together complex, powerful libraries to accomplish specific goals. While converting a single image to a KiCAD footprint goes a long way towards making PCB art, there is still much more that can be done. In a future article, I'll discuss <a href="https://github.com/wntrblm/Gingerbread#using-convert">gingerbread.convert</a>- a powerful tool that can convert an entire design consisting of multiple layers, drills, and complex board outlines.</p>
<aside class="sponsor" id="sponsor">
    <a href="https://pcbway.com" target="_blank"><img src="/static/pcbway.png"></a>
    This artcle was kindly sponsored by <a href="https://pcbway.com" target="_blank">PCBWay</a>. They provide fantastic, high-quality printed circuit boards along with additional services like assembly, 3d printing, and sheet metal fabrication. I use PCBWay for both prototype and production boards and I can't recommend them enough- the board in the photograph at the beginning of this post was made by PCBWay!
</aside>

<div class="footnote">
<hr />
<ol>
<li id="fn:gerbers">
<p>Typically, these are <a href="https://en.wikipedia.org/wiki/Gerber_format"><em>Gerber files</em></a> for printed circuit boards.&#160;<a class="footnote-backref" href="#fnref:gerbers" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:fragmentation">
<p>KiCAD's bitmap2component calls this <a href="https://gitlab.com/kicad/code/kicad/-/blob/2ee65b2d83923acb71aa77ce0efab09a3f2a8f44/libs/kimath/src/geometry/shape_poly_set.cpp#L1079"><em>fragmentation</em></a>.&#160;<a class="footnote-backref" href="#fnref:fragmentation" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:adaptive">
<p>KiCAD has a <a href="https://gitlab.com/kicad/code/kicad/-/blob/2ee65b2d83923acb71aa77ce0efab09a3f2a8f44/bitmap2component/bitmap2component.cpp#L544">nice adaptive algorithm</a> for this that's based on the overall length of the Bezier curve. I ported this to <a href="https://github.com/wntrblm/Gingerbread#using-trace">gingerbread.trace</a> <a href="https://github.com/wntrblm/Gingerbread/blob/e1e5297eb6d48fcbac84907e059d39d02b332f09/gingerbread/_geometry.py#L69">here</a>.&#160;<a class="footnote-backref" href="#fnref:adaptive" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:timestamps">
<p>I'm ignoring the <code>tstamp</code> and <code>tedit</code> fields for now, but they are just <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUIDs</a>.&#160;<a class="footnote-backref" href="#fnref:timestamps" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:dpi">
<p>300 DPI is common for print design, whereas 72 DPI is common for digital design. In modern design software, DPI is really just a choice of how fine of a resolution you want to work with.&#160;<a class="footnote-backref" href="#fnref:dpi" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </content>

  
</article>


    <footer>
      <div class="row">
        <div class="col-md-1 d-none d-md-block img-me-container">
          <img class="img-me img-fluid" src="/static/me.png">
        </div>
        <div class="col-md info">
          <span class="name">Stargirl Flowers</span><br>
          <a href="https://thea.codes"><i class="fa fa-link" aria-hidden="true"></i> thea.codes</a>
          Â· <a href="https://github.com/theacodes" rel="noopener"><i class="fab fa-github" aria-hidden="true"></i> theacodes</a>
          Â· <a href="https://twitter.com/theavalkyrie" rel="noopener"><i class="fab fa-twitter" aria-hidden="true"></i> theavalkyrie</a>
          <br>
          <span class="location"><i class="fas fa-map-marker"></i> Atlanta, Georgia</span>
        </div>
        <div class="col-md">
          <p class="disclaimer">
            &copy; 2018 &mdash; 2020<br>
            All text is available under the <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a> license<br>
            All code is available under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> license
          </p>
      </div>

    </footer>
  </div>

  <!-- webfonts & icons-->
  <link href="/static/fontawesome/css/fontawesome-all.min.css" rel="stylesheet">

  <!-- Google Analytics (that's right, I'm tracking you) -->
  <script async="" src="https://www.google-analytics.com/analytics.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47725506-1', 'blog.thea.codes');
    ga('send', 'pageview');

  </script>

</body>
</html>